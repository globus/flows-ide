import { Button, Tooltip } from "@mantine/core";
import { notifications } from "@mantine/notifications";
import { useGlobusAuth } from "@globus/react-auth-context";
import { flows } from "@globus/sdk";
import { Fragment, PropsWithChildren, useState } from "react";
import { useMonaco } from "@monaco-editor/react";

import { useEditorStore } from "@/stores/editor";

export const GLOBUS_FLOWS_VALIDATION = {
  OWNER: "flows",
  SOURCE: "Globus Flows Validation",
};

export function ValidateButton() {
  const auth = useGlobusAuth();
  const definition = useEditorStore((s) => s.definition);
  const monaco = useMonaco();
  const [validating, setValidating] = useState(false);

  async function validate() {
    if (!monaco) {
      return;
    }

    setValidating(true);

    const model = monaco.editor.getModels()[0];
    /**
     * Remove all of the existing markers generated by the Globus Flows Validation request.
     */
    monaco.editor.removeAllMarkers(GLOBUS_FLOWS_VALIDATION.OWNER);

    const res = await flows.flows.validate(
      {
        payload: {
          // @todo This should probably be a more accurate type.
          definition: definition as any,
        },
      },
      { manager: auth.authorization },
    );

    const json = await res.json();

    if (res.ok) {
      /**
       * If the definition is valid, all markers have been removed and we can
       * display a success toast.
       */
      notifications.show({
        message: "Definition is valid!",
        color: "green",
        position: "bottom-right",
        withCloseButton: true,
      });
      setValidating(false);
      return;
    }

    if (!("error" in json)) {
      notifications.show({
        message: "Unknown validation error encountered.",
        color: "red",
        position: "bottom-right",
        withCloseButton: true,
      });
      setValidating(false);
      return;
    }

    /**
     * Account for validation errors being different shapes...
     */
    const locationErrors = Array.isArray(json.error.detail)
      ? json.error.detail
      : null;
    /**
     * In the toast message, if we have "location errors", we'll just display the number of errors (since they will render as markers in the editor).
     * Otherwise, we'll display the error `message` or `detail`.
     */
    const message = locationErrors
      ? `${json.error.detail.length} error${json.error.detail.length > 1 ? "s" : ""} found â€“ see editor for details.`
      : [json.error.message, json.error.detail].filter(Boolean).join("\n");

    notifications.show({
      title: `Invalid Definition (${json.error.code})`,
      color: "red",
      message,
      position: "bottom-right",
      withCloseButton: true,
      autoClose: false,
    });
    /**
     * When Monaco is ready, and we have location errors, we'll add markers to the editor.
     */
    if (monaco && locationErrors) {
      const markers = locationErrors.map(
        (d: { loc: string[]; msg: string }) => {
          const [_definition, _state, stateName] = d.loc;
          const matches = model.findMatches(
            `"${stateName}":`,
            true,
            true,
            true,
            null,
            true,
          );

          const location = matches[0]?.range ?? {
            startLineNumber: 1,
            endLineNumber: 1,
            startColumn: 1,
            endColumn: 1,
          };

          return {
            ...location,
            owner: GLOBUS_FLOWS_VALIDATION.OWNER,
            source: GLOBUS_FLOWS_VALIDATION.SOURCE,
            message: d.msg,
            severity: 8,
          };
        },
      );

      monaco.editor.setModelMarkers(
        model,
        GLOBUS_FLOWS_VALIDATION.OWNER,
        markers,
      );
      monaco.editor.getEditors()[0].revealPositionNearTop({
        lineNumber: markers[0].startLineNumber,
        column: markers[0].startColumn,
      });
      monaco.editor.getEditors()[0].focus();
    }

    setValidating(false);
  }

  const Wrapper =
    auth.isAuthenticated === false
      ? ({ children }: PropsWithChildren) => (
          <Tooltip
            withArrow
            label="You must sign in in order to validate using the Globus Flows service."
          >
            {children}
          </Tooltip>
        )
      : Fragment;
  return (
    <Wrapper>
      <Button
        loading={validating}
        onClick={validate}
        color="orange"
        size="xs"
        disabled={!monaco || !auth.isAuthenticated || validating}
      >
        Validate
      </Button>
    </Wrapper>
  );
}
